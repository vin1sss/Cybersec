---
title: "Resposta a Incidente de Malware"
tags: [procedimento, malware, resposta-a-incidente, memoria, windows, dfir, ioc]
status: rascunho
---

# Resposta a Incidente de Malware

Este procedimento descreve um fluxo **prático e repetível** para investigar suspeita de malware em um host (tipicamente Windows), usando o que já está no repositório: coleta/aquisição, análise de memória (Volatility), análise de disco (Autopsy/TSK), artefatos de Windows (RegRipper, Chainsaw/EvtxECmd), timeline (plaso/psort) e utilitários (hashes, CyberChef, ExifTool).  
Objetivo: **identificar o processo malicioso, obter o binário, entender o que ele fez e gerar IoCs**.

---

## 1. Cenário e objetivos

Você vai usar este procedimento quando tiver algo como:

- EDR/antivírus alertou para execução suspeita;
- usuário informou comportamento estranho (janelas rápidas, criptografia, pop-up);
- tráfego de rede indicou beaconing;
- logs mostraram execução de `powershell.exe` com argumento esquisito;
- dump de memória apontou código injetado.

O que você precisa ao final:

1. nome e caminho do binário malicioso;
2. hash do binário;
3. processo/pid e árvore de processos;
4. o que o malware fez (criou chave? baixou segundo estágio? se conectou a C2?);
5. período da atividade, para correlacionar com logs;
6. IoCs (domínios, IPs, paths, hashes) para bloquear.

---

## 2. Ordem geral (resumo)

1. **Preservar e coletar** (memória + disco/artefatos)
2. **Analisar memória** (Volatility → processos, conexões, injeção)
3. **Localizar o binário na imagem** (Autopsy/TSK) e extrair
4. **Cruzar com artefatos de Windows e logs** (execução, persistência)
5. **Montar timeline do período** (plaso/psort)
6. **Gerar IoCs e registrar**

---

## 3. Preservar e coletar

Exatamente como no procedimento de aquisição padrão:

1. **Registrar data/hora e contexto** (usuário, hostname, IP, alertas recebidos).
2. **Coletar memória** (DumpIt, FTK Imager RAM, winpmem) → salvar e hashear.
3. (Opcional, mas recomendado) **rodar KAPE** para capturar artefatos de alto valor:
```text
   kape.exe --tsource C: --tdest E:\caso\kape --target !SANS_Triage
````

4. **Aquisição de disco/imagem** se o caso permitir (FTK Imager / Guymager / dd).

Por que memória primeiro? Porque malware que injeta código, que roda só em RAM ou que baixa payload em tempo de execução **pode não deixar rastro completo em disco**. Memória é onde a verdade está.

---

## 4. Análise de memória (Volatility)

Abrir o dump no Volatility (vide `04_Ferramentas/04_Memoria/01_Volatility.md`).

### 4.1 Identificar o sistema

```bash
python3 vol.py -f memdump.raw windows.info
```

### 4.2 Listar processos e achar o suspeito

Use mais de um método:

```bash
python3 vol.py -f memdump.raw windows.pslist
python3 vol.py -f memdump.raw windows.pstree
python3 vol.py -f memdump.raw windows.psscan
```

Compare:

* processos que não deveriam existir;
* processos com nome “certo” mas caminho errado;
* processos filhos de `explorer.exe` ou `winword.exe` em horário estranho;
* PIDs que apareceram no alerta.

### 4.3 Ver conexões

```bash
python3 vol.py -f memdump.raw windows.netstat
```

Se aparecer IP/domínio suspeito, já anotar como possível C2.

### 4.4 Caçar injeção/código escondido

```bash
python3 vol.py -f memdump.raw windows.malfind
```

Procure blocos com permissão de execução + regiões sem mapeamento de arquivo. Se encontrar, é forte sinal de injeção.

### 4.5 Dump do processo suspeito

Se você identificou o PID malicioso (ex.: 1640), faça dump:

```bash
python3 vol.py -f memdump.raw windows.dumpfiles --pid 1640 -D ./dumps
# ou, dependendo do plugin disponível:
python3 vol.py -f memdump.raw windows.memdump --pid 1640 -D ./dumps
```

Isso te dá uma cópia do executável/injetado para análise e hash.

**Resultado desta fase**:

* PID(s) suspeitos
* nome do processo
* possíveis conexões de rede
* dump do processo
* horário aproximado da execução (pelas estruturas de memória)

---

## 5. Localizar o binário na imagem/disco

Agora, com o nome/caminho do malware (ex.: `C:\Users\Public\svchost.exe` que não devia estar aí), abra a **imagem** no Autopsy ou TSK:

1. montar/ingestar imagem;
2. navegar até o caminho apontado pela memória;
3. **extrair o arquivo** exatamente como está no disco;
4. calcular **SHA-256** e **MD5** do arquivo extraído;
5. comparar com o hash do dump (se tiver) — pode não bater se o malware estiver empacotado/descomprimido só em RAM.

Se o caminho não estiver óbvio (malware apagou), use:

* timeline do sistema de arquivos (Autopsy/TSK) para arquivos criados perto do horário;
* carving de arquivos executáveis;
* olhar `C:\Users\<user>\AppData\Local\Temp` e similares.

---

## 6. Artefatos de Windows e persistência

Malware costuma deixar **persistência**. Vá atrás usando o material de `03_Analise_de_Sistemas/01_Windows` e `04_Ferramentas/03_Registro_e_Artefatos_Windows`:

Coisas para olhar:

1. **Run / RunOnce** (HKCU e HKLM)

   * usar RegRipper ou regipy para puxar chaves de inicialização;
2. **Serviços e agendador de tarefas**

   * malware pode criar tarefa para reexecutar;
3. **Recentes / LNK / Jump Lists**

   * se o malware foi baixado e executado manualmente, às vezes aparece;
4. **Prefetch**

   * se o prefetch estiver ativo, vai mostrar o executável e quantas vezes foi executado;
5. **Logs (EVTX)**

   * eventos 4688 (criação de processo) e eventos de serviço.

Se encontrar persistência, anotar:

* chave/tarefa/serviço criado;
* caminho apontado;
* data/hora da criação.

Isso conta a história e ajuda na limpeza.

---

## 7. Timeline do período

Para amarrar tudo (download → execução → persistência → comunicação), gere timeline:

1. montar imagem em `/mnt/evidencia`
2. rodar:

   ```bash
   log2timeline.py timeline.plaso /mnt/evidencia
   ```
3. exportar o intervalo em que o malware rodou (você já sabe do dump/logs):

   ```bash
   psort.py -o L2tcsv -w malware_intervalo.csv --slice "2025-11-07T13:50:00 2025-11-07T14:30:00" timeline.plaso
   ```

Na timeline, procure:

* criação do arquivo malicioso;
* execução do programa;
* criação de chave de persistência;
* downloads adicionais;
* atividades de navegação que podem indicar vetor (phishing, download de doc).

Se quiser trabalhar melhor, joga no Timesketch.

---

## 8. Geração de IoCs

Com o binário e a análise de memória você já consegue montar uma lista de IoCs para detecção e bloqueio:

* **Hashes**: SHA-256 e MD5 do binário extraído e do dump
* **Caminhos**: `C:\Users\Public\...`, `%APPDATA%\...`, `%TEMP%\...`
* **Persistência**: chave de registro específica, nome da tarefa, nome de serviço
* **Rede**: IPs e domínios vistos no `windows.netstat` e no PCAP (se houver)
* **Nomes de processo incomuns**: para hunting em outros hosts

Documente assim:

```text
IOC:
  Tipo: hash
  Valor: 5f2c... (SHA-256)
  Arquivo: C:\Users\Public\svchost.exe
  Fonte: extraído da imagem

IOC:
  Tipo: domínio
  Valor: updates-check[.]com
  Fonte: windows.netstat (Volatility) 2025-11-07 13:58:11
```

---

## 9. Checklist rápido

* [ ] Dump de memória coletado e hash registrado
* [ ] Volatility rodado: pslist/pstree/psscan
* [ ] Processo suspeito identificado (PID + parent)
* [ ] Conexões observadas (netstat)
* [ ] malfind rodado (injeção verificada)
* [ ] Dump do processo/arquivo feito
* [ ] Binário encontrado na imagem/disco e extraído
* [ ] Hashes calculados
* [ ] Persistência verificada (registro/tarefas/serviços)
* [ ] Timeline do período gerada
* [ ] IoCs documentados

---

## 10. Relação com outras pastas

* Coleta e aquisição → `02_Coleta_de_Evidencias/*`
* Análise de memória → `04_Ferramentas/04_Memoria/01_Volatility.md`
* Análise de disco/imagem → `04_Ferramentas/02_Analise_de_Disco_Imagem/*`
* Artefatos de Windows → `03_Analise_de_Sistemas/01_Windows/*` e `04_Ferramentas/03_Registro_e_Artefatos_Windows/*`
* Timeline → `04_Ferramentas/05_Timeline_e_Correlacao/*`
* Utilitários (hash, CyberChef, ExifTool) → `04_Ferramentas/08_Utilitarios_de_Apoio/*`

Este procedimento amarra todas essas partes focando em **malware em host Windows**, que é o caso mais frequente.